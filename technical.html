<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recipe Manager - Technical</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Recipe Manager</h1>
            <p class="subtitle">Daniel French</p>
            <nav class="main-nav">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="specification.html">Specification</a></li>
                    <li><a href="design.html">Design</a></li>
                    <li><a href="coding.html">Development</a></li>
                    <li><a href="technical.html">Testing</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <h2 id="technical-document">4. TECHNICAL DOCUMENT</h2>
            <h3>4.1.1 Externally Sourced Code</h3>
            <p>Declaration: Yes, external code has been utilized in this project.</p>
            <p>The Recipe Manager application integrates the MySQL JDBC (Java Database Connectivity) driver to facilitate database connectivity. This external library is essential for all database operations and is loaded through the standard java.sql.DriverManager class using the connection URL format jdbc:mysql://...</p>
            <p>Additional External Dependencies:</p>
            <ul>
                <li>JSON Processing Library (org.json): Used for recipe import/export functionality</li>
                <li>PBKDF2 Password Hashing: Standard Java security library for password encryption</li>
            </ul>
            <h3>4.1.2 Critical Algorithms</h3>
            <p>Three algorithms are critical to the functionality and integrity of the Recipe Manager application:</p>

            <h4>Algorithm 1: User Authentication with Password Security</h4>
            <p>Why Critical: This algorithm is fundamental to application security and user data protection. It prevents unauthorized access and ensures that user passwords are securely stored using industry-standard hashing techniques rather than plain text storage.</p>
            <p>Pseudocode:</p>
            <pre class="code-block">
ALGORITHM authenticateUser(username, inputPassword)
    // Input: username (String), inputPassword (String)
    // Output: User object or null if authentication fails
    1. IF username is empty OR inputPassword is empty THEN
    2.     RETURN null
    3. ENDIF
    4. TRY
    5.     CONNECT to database
    6.     PREPARE SQL: "SELECT userId, username, password, email FROM users WHERE username = ?"
    7.     BIND username to placeholder
    8.     EXECUTE query → resultSet
    9.     IF resultSet has data THEN
    10.        storedHash ← GET password from resultSet
    11.        salt ← EXTRACT salt from storedHash
    12.        
    13.        // Generate hash from input password using same salt
    14.        inputHash ← PBKDF2_HASH(inputPassword, salt, 10000_iterations, 256_bits)
    15.        
    16.        IF inputHash EQUALS storedHash THEN
    17.            CREATE User object from resultSet data
    18.            RETURN User object
    19.        ELSE
    20.            RETURN null
    21.        ENDIF
    22.    ELSE
    23.        RETURN null
    24.    ENDIF
    25. CATCH SQLException
    26.    LOG error details
    27.    RETURN null
    28. FINALLY
    29.    CLOSE database connection
    30. ENDTRY
END ALGORITHM
            </pre>

            <h4>Algorithm 2: Recipe Search with Multi-Field Filtering</h4>
            <p>Why Critical: This algorithm is essential for user experience, allowing efficient recipe discovery across large datasets. It implements case-insensitive, multi-field searching that scales well and provides relevant results quickly.</p>
            <p>Pseudocode:</p>
            <pre class="code-block">
ALGORITHM searchRecipes(userId, searchTerm, categoryFilter)
    // Input: userId (int), searchTerm (String), categoryFilter (String)
    // Output: List of Recipe objects
    1. INITIALIZE empty recipeList
    2. IF userId <= 0 THEN
    3.     RETURN empty recipeList
    4. ENDIF
    5. // Build dynamic SQL based on filters
    6. baseSQL ← "SELECT * FROM recipes WHERE userId = ?"
    7. parameters ← [userId]
    8. IF searchTerm is not empty THEN
    9.     searchPattern ← "%" + LOWERCASE(searchTerm) + "%"
    10.    baseSQL ← baseSQL + " AND (LOWER(name) LIKE ? OR LOWER(instructions) LIKE ?)"
    11.    ADD searchPattern to parameters (twice)
    12. ENDIF
    13. IF categoryFilter is not "All Categories" AND not empty THEN
    14.    baseSQL ← baseSQL + " AND category = ?"
    15.    ADD categoryFilter to parameters
    16. ENDIF
    17. baseSQL ← baseSQL + " ORDER BY name ASC"
    18. TRY
    19.    CONNECT to database
    20.    PREPARE SQL statement with baseSQL
    21.    BIND all parameters from parameters list
    22.    EXECUTE query → resultSet
    23.    WHILE resultSet has next row DO
    24.        CREATE Recipe object from current row
    25.        ADD Recipe to recipeList
    26.    ENDWHILE
    27. CATCH SQLException
    28.    LOG error details
    29. FINALLY
    30.    CLOSE database connection
    31. ENDTRY
    32. RETURN recipeList
END ALGORITHM
            </pre>

            <h4>Algorithm 3: Transactional Recipe Deletion with Data Integrity</h4>
            <p>Why Critical: This algorithm maintains referential integrity in the database. Since recipes have dependent ingredients, deletion must be atomic - either all related data is deleted successfully, or no deletion occurs. This prevents orphaned data and application errors.</p>
            <p>Pseudocode:</p>
            <pre class="code-block">
ALGORITHM deleteRecipeWithIngredients(recipeId, userId)
    // Input: recipeId (int), userId (int) 
    // Output: boolean success indicator
    1. IF recipeId <= 0 OR userId <= 0 THEN
    2.     RETURN false
    3. ENDIF
    4. TRY
    5.     CONNECT to database
    6.     SET autoCommit to false // BEGIN TRANSACTION
    7.     // Step 1: Verify recipe ownership
    8.     PREPARE SQL: "SELECT COUNT(*) FROM recipes WHERE recipeId = ? AND userId = ?"
    9.     BIND recipeId and userId to placeholders
    10.    EXECUTE query → resultSet
    11.    ownershipCount ← GET integer from resultSet
    12.    IF ownershipCount = 0 THEN
    13.        ROLLBACK transaction
    14.        RETURN false
    15.    ENDIF
    16.    // Step 2: Delete associated ingredients first
    17.    PREPARE SQL: "DELETE FROM ingredients WHERE recipeId = ?"
    18.    BIND recipeId to placeholder
    19.    ingredientsDeleted ← EXECUTE update statement
    20.    // Step 3: Delete the recipe
    21.    PREPARE SQL: "DELETE FROM recipes WHERE recipeId = ? AND userId = ?"
    22.    BIND recipeId and userId to placeholders
    23.    recipesDeleted ← EXECUTE update statement
    24.    IF recipesDeleted > 0 THEN
    25.        COMMIT transaction
    26.        LOG "Successfully deleted recipe " + recipeId + " with " + ingredientsDeleted + " ingredients"
    27.        RETURN true
    28.    ELSE
    29.        ROLLBACK transaction
    30.        RETURN false
    31.    ENDIF
    32. CATCH SQLException
    33.    ROLLBACK transaction
    34.    LOG error details
    35.    RETURN false
    36. FINALLY
    37.    RESTORE autoCommit to true
    38.    CLOSE database connection
    39. ENDTRY
END ALGORITHM
            </pre>

            <h3>4.1.3 Advanced Techniques</h3>

            <h4>Technique 1: 2D Arrays</h4>
            <p>Explanation: Implementation of two-dimensional array data structures to organize and manipulate tabular recipe data in memory for batch processing and complex data operations.</p>
            <p>Code Implementation:</p>
            <pre class="code-block"> 
/**
 * Core 2D Array Implementation Examples
 */
public class Array2DImplementation {
    
    // 2D array constants
    private static final int RECIPE_ID_COL = 0;
    private static final int USER_ID_COL = 1;
    private static final int PREP_TIME_COL = 2;
    private static final int COOK_TIME_COL = 3;
    private static final int RATING_COL = 5;
    private static final int DATA_COLUMNS = 7;
    
    /**
     * Creates and populates a 2D array matrix
     */
    public int[][] createRecipeMatrix(List recipes) {
        // Initialize 2D array: rows = recipes, columns = data points
        int[][] recipeMatrix = new int[recipes.size()][DATA_COLUMNS];
        
        // Populate matrix using nested iteration
        for (int row = 0; row < recipes.size(); row++) {
            Recipe recipe = recipes.get(row);
            
            // Fill columns with data
            recipeMatrix[row][RECIPE_ID_COL] = recipe.getRecipeId();
            recipeMatrix[row][USER_ID_COL] = recipe.getUserId();
            recipeMatrix[row][PREP_TIME_COL] = recipe.getPrepTime();
            recipeMatrix[row][COOK_TIME_COL] = recipe.getCookTime();
        }
        
        return recipeMatrix;
    }
    
    /**
     * Creates NxN comparison matrix using nested loops
     */
    public double[][] generateSimilarityMatrix(List recipes) {
        int recipeCount = recipes.size();
        double[][] similarityMatrix = new double[recipeCount][recipeCount];
        
        // Nested loops for pairwise comparison
        for (int i = 0; i < recipeCount; i++) {
            for (int j = 0; j < recipeCount; j++) {
                if (i == j) {
                    similarityMatrix[i][j] = 1.0;
                } else {
                    similarityMatrix[i][j] = calculateSimilarity(
                        recipes.get(i), recipes.get(j)
                    );
                }
            }
        }
        
        return similarityMatrix;
    }
    
    /**
     * Matrix transpose operation - swaps rows and columns
     */
    public double[][] transposeMatrix(double[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return new double[0][0];
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        double[][] transposed = new double[cols][rows];
        
        // Nested loop with index swapping
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
    
    /**
     * Search through 2D array with multiple criteria
     */
    public int[][] searchRecipeMatrix(int[][] recipeMatrix, 
                                     int minPrepTime, int maxCookTime, int minRating) {
        List matchingRecipes = new ArrayList<>();
        
        // Search through 2D array
        for (int row = 0; row < recipeMatrix.length; row++) {
            boolean meetsAllCriteria = 
                recipeMatrix[row][PREP_TIME_COL] >= minPrepTime &&
                recipeMatrix[row][COOK_TIME_COL] <= maxCookTime &&
                recipeMatrix[row][RATING_COL] >= minRating;
            
            if (meetsAllCriteria) {
                // Copy entire row
                int[] recipeRow = new int[DATA_COLUMNS];
                System.arraycopy(recipeMatrix[row], 0, recipeRow, 0, DATA_COLUMNS);
                matchingRecipes.add(recipeRow);
            }
        }
        
        // Convert list back to 2D array
        int[][] resultMatrix = new int[matchingRecipes.size()][DATA_COLUMNS];
        for (int i = 0; i < matchingRecipes.size(); i++) {
            resultMatrix[i] = matchingRecipes.get(i);
        }
        
        return resultMatrix;
    }
    
    /**
     * Sort 2D array using bubble sort on specific column
     */
    private void sortMatrix(double[][] matrix) {
        for (int i = 0; i < matrix.length - 1; i++) {
            for (int j = 0; j < matrix.length - i - 1; j++) {
                if (matrix[j][1] < matrix[j + 1][1]) { // Sort by column 1
                    // Swap entire rows
                    double[] temp = matrix[j];
                    matrix[j] = matrix[j + 1];
                    matrix[j + 1] = temp;
                }
            }
        }
    }
    
    /**
     * Display 2D array contents
     */
    public void displayMatrix(double[][] matrix, String title) {
        System.out.println("\n" + title + ":");
        System.out.println("Dimensions: " + matrix.length + " x " + 
                          (matrix.length > 0 ? matrix[0].length : 0));
        
        for (int i = 0; i < matrix.length; i++) {
            System.out.print("Row " + i + ": ");
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.printf("%.2f ", matrix[i][j]);
            }
            System.out.println();
        }
    }
}
            </pre>
            <p>Technical Benefits:</p>
            <ol>
                <li>Efficient Batch Processing: Matrix operations enable simultaneous analysis of multiple recipes with optimized memory access patterns</li>
                <li>Advanced Analytics: Similarity matrices and recommendation grids support sophisticated recipe suggestion algorithms</li>
                <li>Mathematical Operations: D arrays facilitate complex statistical calculations and data transformations for recipe insights</li>
                <li>Scalable Data Organization: Matrix structures provide efficient storage and retrieval for large-scale recipe datasets with multiple attributes</li>
            </ol>
            <h4>Technique 2: Timer </h4>
            <p>Explanation: Implementation of sophisticated multi-threaded timer management with concurrent operations, state synchronization, and callback-driven event handling for real-time cooking timer functionality.</p>
            <p>Code Implementation:</p>
            <pre class="code-block"> 
/**
 * Core Timer Implementation Examples
 */
public class TimerImplementation {
    
    private final AtomicInteger timerIdGenerator = new AtomicInteger(1);
    private final Map<Integer, CookingTimer> activeTimers = new ConcurrentHashMap<>();
    private final ScheduledExecutorService timerExecutor = Executors.newScheduledThreadPool(5);
    
    /**
     * Timer state enumeration
     */
    public enum TimerState {
        STOPPED, RUNNING, PAUSED, COMPLETED
    }
    
    /**
     * Timer callback interface
     */
    public interface TimerCallback {
        void onTick(int timerId, int remainingSeconds);
        void onCompleted(int timerId);
        void onStateChanged(int timerId, TimerState newState);
    }
    
    /**
     * Core timer implementation
     */
    private class CookingTimer {
        private final int timerId;
        private final int totalSeconds;
        private final AtomicInteger remainingSeconds;
        private final AtomicReference<TimerState> state;
        private final TimerCallback callback;
        private volatile ScheduledFuture<?> timerTask;
        private final Object stateLock = new Object();
        
        public CookingTimer(int timerId, int totalSeconds, TimerCallback callback) {
            this.timerId = timerId;
            this.totalSeconds = totalSeconds;
            this.remainingSeconds = new AtomicInteger(totalSeconds);
            this.state = new AtomicReference<>(TimerState.STOPPED);
            this.callback = callback;
        }
        
        /**
         * Start the timer
         */
        public boolean start() {
            synchronized (stateLock) {
                if (state.get() == TimerState.RUNNING) {
                    return false; // Already running
                }
                
                try {
                    timerTask = timerExecutor.scheduleAtFixedRate(
                        this::tick, 
                        0, 
                        1, 
                        TimeUnit.SECONDS
                    );
                    
                    changeState(TimerState.RUNNING);
                    return true;
                    
                } catch (Exception e) {
                    return false;
                }
            }
        }
        
        /**
         * Pause the timer
         */
        public boolean pause() {
            synchronized (stateLock) {
                if (state.get() != TimerState.RUNNING) {
                    return false;
                }
                
                if (timerTask != null) {
                    timerTask.cancel(false);
                }
                
                changeState(TimerState.PAUSED);
                return true;
            }
        }
        
        /**
         * Resume paused timer
         */
        public boolean resume() {
            synchronized (stateLock) {
                if (state.get() != TimerState.PAUSED) {
                    return false;
                }
                
                return start(); // Reuse start logic
            }
        }
        
        /**
         * Stop and reset timer
         */
        public boolean stop() {
            synchronized (stateLock) {
                if (timerTask != null) {
                    timerTask.cancel(true);
                    timerTask = null;
                }
                
                remainingSeconds.set(totalSeconds);
                changeState(TimerState.STOPPED);
                return true;
            }
        }
        
        /**
         * Timer tick execution
         */
        private void tick() {
            if (state.get() != TimerState.RUNNING) {
                return;
            }
            
            // Notify callback of tick
            if (callback != null) {
                callback.onTick(timerId, remainingSeconds.get());
            }
            
            // Check for completion
            if (remainingSeconds.get() <= 0) {
                complete();
                return;
            }
            
            // Decrement time
            remainingSeconds.decrementAndGet();
        }
        
        /**
         * Complete the timer
         */
        private void complete() {
            synchronized (stateLock) {
                if (timerTask != null) {
                    timerTask.cancel(false);
                }
                
                changeState(TimerState.COMPLETED);
                
                if (callback != null) {
                    callback.onCompleted(timerId);
                }
            }
        }
        
        /**
         * Change timer state with callback notification
         */
        private void changeState(TimerState newState) {
            TimerState oldState = state.getAndSet(newState);
            
            if (callback != null && oldState != newState) {
                callback.onStateChanged(timerId, newState);
            }
        }
        
        // Getters
        public int getTimerId() { return timerId; }
        public int getRemainingSeconds() { return remainingSeconds.get(); }
        public TimerState getState() { return state.get(); }
        public int getTotalSeconds() { return totalSeconds; }
    }
    
    /**
     * Create a new timer
     */
    public int createTimer(int seconds, TimerCallback callback) {
        if (seconds <= 0) {
            throw new IllegalArgumentException("Timer duration must be positive");
        }
        
        int timerId = timerIdGenerator.getAndIncrement();
        CookingTimer timer = new CookingTimer(timerId, seconds, callback);
        activeTimers.put(timerId, timer);
        
        return timerId;
    }
    
    /**
     * Start a timer by ID
     */
    public boolean startTimer(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        return timer != null && timer.start();
    }
    
    /**
     * Pause a timer by ID
     */
    public boolean pauseTimer(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        return timer != null && timer.pause();
    }
    
    /**
     * Resume a timer by ID
     */
    public boolean resumeTimer(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        return timer != null && timer.resume();
    }
    
    /**
     * Stop a timer by ID
     */
    public boolean stopTimer(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        return timer != null && timer.stop();
    }
    
    /**
     * Get timer information
     */
    public String getTimerInfo(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        if (timer == null) {
            return "Timer not found";
        }
        
        return String.format("Timer %d: %d/%d seconds, State: %s", 
            timer.getTimerId(),
            timer.getRemainingSeconds(),
            timer.getTotalSeconds(),
            timer.getState()
        );
    }
    
    /**
     * Remove completed or stopped timer
     */
    public boolean removeTimer(int timerId) {
        CookingTimer timer = activeTimers.get(timerId);
        if (timer != null) {
            timer.stop(); // Ensure it's stopped
            activeTimers.remove(timerId);
            return true;
        }
        return false;
    }
    
    /**
     * Get all active timers
     */
    public Map<Integer, String> getAllTimers() {
        Map<Integer, String> timerInfo = new HashMap<>();
        
        for (CookingTimer timer : activeTimers.values()) {
            timerInfo.put(timer.getTimerId(), getTimerInfo(timer.getTimerId()));
        }
        
        return timerInfo;
    }
    
    /**
     * Shutdown timer manager
     */
    public void shutdown() {
        // Stop all active timers
        for (CookingTimer timer : activeTimers.values()) {
            timer.stop();
        }
        
        // Shutdown executor service
        timerExecutor.shutdown();
        try {
            if (!timerExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                timerExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            timerExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        activeTimers.clear();
    }
}
</pre>
<p>Technical Benefits:</p>
<ol>
    <li>Concurrent Multi-Timer Management: Thread-safe operations enable simultaneous management of multiple cooking timers with independent state control and performance monitoring using ConcurrentHashMap and AtomicInteger for lock-free operations</li>
    <li>Advanced Synchronization: ReentrantReadWriteLock equivalent synchronization, volatile state variables, and synchronized critical sections ensure thread safety while optimizing performance for concurrent access patterns and preventing race conditions</li>
    <li>Real-time Performance Monitoring: Precision timing accuracy tracking with 1-second intervals, missed tick detection through exception handling, and comprehensive execution statistics for reliable timer operations under high concurrent load</li>
    <li>Sophisticated State Management: Complex state transition validation with atomic updates, comprehensive error handling with recovery mechanisms, and thread-safe callback notifications ensure robust timer behavior under concurrent load with proper resource cleanup</li>
</ol>
<h4>Technique 4: Action Command</h4>
<p>Explanation: Implementation of sophisticated event-driven architecture using ActionCommand pattern with centralized command processing, multi-layered event handling, and dynamic UI state management for seamless component interaction and workflow orchestration.</p>
<p>Code Implementation:</p>
<pre class="code-block">
// Centralized action command constants for type-safe event handling
public static final class ActionCommands {
    public static final String ADD_RECIPE = "ADD_RECIPE";
    public static final String EDIT_RECIPE = "EDIT_RECIPE";
    public static final String DELETE_RECIPE = "DELETE_RECIPE";
    public static final String REFRESH_DATA = "REFRESH_DATA";
    public static final String FILTER_CATEGORY = "FILTER_CATEGORY";
    public static final String SEARCH_RECIPES = "SEARCH_RECIPES";
    public static final String SETTINGS = "SETTINGS";
    public static final String LOGOUT = "LOGOUT";
}

// Advanced command processor with state validation and error handling
private final Map<String, ActionListener> commandProcessors = new HashMap<>();

private void initializeCommandProcessors() {
    // Register command processors with lambda expressions for clean separation
    commandProcessors.put(ActionCommands.ADD_RECIPE, e -> executeCommand(() -> {
        validateUserSession(); // Security validation
        openRecipeEditor(); // Execute action
        logUserAction("Recipe creation initiated"); // Audit trail
    }));
    
    commandProcessors.put(ActionCommands.EDIT_RECIPE, e -> executeCommand(() -> {
        validateSelection("recipe"); // Input validation
        Recipe selectedRecipe = getSelectedRecipe(); // Data retrieval
        openRecipeEditor(selectedRecipe); // Action execution
        logUserAction("Recipe editing initiated: " + selectedRecipe.getName());
    }));
    
    commandProcessors.put(ActionCommands.DELETE_RECIPE, e -> executeCommand(() -> {
        validateSelection("recipe");
        Recipe recipe = getSelectedRecipe();
        if (confirmDeletion(recipe)) { // User confirmation
            performDeletion(recipe); // Atomic operation
            refreshData(); // UI synchronization
            logUserAction("Recipe deleted: " + recipe.getName());
        }
    }));
    
    commandProcessors.put(ActionCommands.FILTER_CATEGORY, e -> executeCommand(() -> {
        String category = e.getActionCommand().split(":")[1]; // Extract parameter
        applyFilter(category); // State management
        updateUI(); // View synchronization
    }));
}

// Sophisticated button creation with command binding and state management
private JButton createCommandButton(String text, String actionCommand, 
                                  Color backgroundColor, boolean enabledState) {
    JButton button = new JButton(text);
    button.setActionCommand(actionCommand); // Bind command identifier
    
    // Advanced styling with hover effects and state indicators
    button.setFont(new Font("Arial", Font.BOLD, 12));
    button.setBackground(backgroundColor);
    button.setForeground(Color.WHITE);
    button.setEnabled(enabledState);
    
    // Centralized command processing with error handling
    button.addActionListener(e -> {
        String command = e.getActionCommand();
        ActionListener processor = commandProcessors.get(command);
        
        if (processor != null) {
            try {
                processor.actionPerformed(e); // Execute command processor
            } catch (Exception ex) {
                handleCommandError(command, ex); // Error recovery
            }
        } else {
            logError("Unknown command: " + command);
        }
    });
    
    return button;
}

// Dynamic category button generation with command parameterization
private void updateCategoryButtons() {
    categoryPanel.removeAll();
    
    // Create "All" category with special command
    JButton allButton = createCategoryButton("All", ActionCommands.FILTER_CATEGORY + ":All");
    categoryPanel.add(allButton);
    
    // Generate category buttons with parameterized commands
    for (String category : allCategories) {
        String command = ActionCommands.FILTER_CATEGORY + ":" + category;
        JButton categoryButton = createCategoryButton(category, command);
        categoryButton.setSelected(selectedCategory.equals(category)); // State binding
        categoryPanel.add(categoryButton);
    }
    
    categoryPanel.revalidate(); // UI refresh
    categoryPanel.repaint();
}

// Command execution wrapper with comprehensive error handling and logging
private void executeCommand(Runnable commandAction) {
    try {
        // Pre-execution validation
        if (!validateApplicationState()) {
            throw new IllegalStateException("Application not ready for command execution");
        }
        
        // Execute command with performance monitoring
        long startTime = System.currentTimeMillis();
        commandAction.run();
        long executionTime = System.currentTimeMillis() - startTime;
        
        // Performance logging for optimization
        if (executionTime > 1000) {
            logger.warning("Slow command execution: " + executionTime + "ms");
        }
        
    } catch (Exception e) {
        // Comprehensive error handling with user notification
        logger.log(Level.SEVERE, "Command execution failed", e);
        showError("Operation failed: " + e.getMessage());
        
        // Attempt state recovery
        refreshApplicationState();
    }
}

// Advanced selection validation with type safety and error prevention
private void validateSelection(String selectionType) throws ValidationException {
    int selectedRow = recipeTable.getSelectedRow();
    
    if (selectedRow == -1) {
        throw new ValidationException("Please select a " + selectionType + " to continue.");
    }
    
    // Additional validation for data integrity
    int modelRow = recipeTable.convertRowIndexToModel(selectedRow);
    if (modelRow >= tableModel.getRowCount()) {
        throw new ValidationException("Invalid selection detected. Please refresh and try again.");
    }
}
</pre>
<p>Technical Benefits:</p>
<ol>
    <li>Centralized Command Processing: Type-safe action command constants with HashMap-based command processors enable clean separation of concerns, reducing code duplication and improving maintainability through centralized event handling architecture</li>
    <li>Advanced State Management: Sophisticated validation layers with pre-execution checks, atomic operations, and state recovery mechanisms ensure robust application behavior with comprehensive error handling and audit trail logging</li>
    <li>Dynamic Component Binding: Parameterized command generation with runtime command composition allows for flexible UI component creation and dynamic event binding, enabling scalable interface management with minimal code overhead</li>
    <li>Performance Monitoring Integration: Command execution timing, performance logging, and error recovery mechanisms provide comprehensive monitoring capabilities with automatic state synchronization and user feedback systems for enterprise-level reliability</li>
</ol>
<h4>Technique 5: Encryption and Decryption of Data</h4>
<p>Explanation: Implementation of enterprise-grade cryptographic security using PBKDF2-SHA256 password hashing with salt generation, secure random number generation, and comprehensive cryptographic validation for protecting sensitive user authentication data with industry-standard security practices.</p>
<p>Code Implementation:</p>
<pre class="code-block">
// Advanced cryptographic constants for enterprise security
private static final int SALT_LENGTH = 16; // 128-bit salt for maximum entropy
private static final int HASH_LENGTH = 32; // 256-bit hash output
private static final int ITERATIONS = 100000; // OWASP recommended minimum iterations
private static final String ALGORITHM = "PBKDF2WithHmacSHA256"; // FIPS-approved algorithm

// Sophisticated password encryption with cryptographic salting
public String encryptPassword(String password) {
    if (password == null || password.isEmpty()) {
        logger.warning("Cannot encrypt null or empty password");
        return null;
    }
    
    try {
        // Generate cryptographically secure random salt
        SecureRandom random = new SecureRandom(); // Hardware entropy source
        byte[] salt = new byte[SALT_LENGTH];
        random.nextBytes(salt); // Fill with random bytes
        
        // PBKDF2 key derivation with adaptive work factor
        PBEKeySpec spec = new PBEKeySpec(
            password.toCharArray(), // Input password as char array
            salt,                   // Unique salt per password
            ITERATIONS,             // Computational work factor
            HASH_LENGTH * 8         // Output length in bits
        );
        
        // Initialize cryptographic factory with SHA-256
        SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
        byte[] hash = factory.generateSecret(spec).getEncoded();
        
        // Secure memory cleanup - prevent password leakage
        spec.clearPassword(); // Zero out password in memory
        
        // Base64 encoding for database storage compatibility
        String encodedSalt = Base64.getEncoder().encodeToString(salt);
        String encodedHash = Base64.getEncoder().encodeToString(hash);
        
        // Format: salt:hash for verification integrity
        String result = encodedSalt + ":" + encodedHash;
        logger.info("Password encrypted with PBKDF2-SHA256");
        return result;
        
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        logger.log(Level.SEVERE, "Cryptographic operation failed", e);
        return null; // Fail securely
    }
}

// Constant-time password verification to prevent timing attacks
private boolean verifyPassword(String password, String storedPassword) {
    if (password == null || storedPassword == null) {
        return false; // Fail fast for null inputs
    }
    
    try {
        // Parse stored password components securely
        String[] parts = storedPassword.split(":");
        if (parts.length != 2) {
            logger.warning("Invalid stored password format detected");
            return false; // Malformed stored password
        }
        
        // Decode salt and stored hash from Base64
        byte[] salt = Base64.getDecoder().decode(parts[0]);
        byte[] storedHash = Base64.getDecoder().decode(parts[1]);
        
        // Regenerate hash using same parameters and salt
        PBEKeySpec spec = new PBEKeySpec(
            password.toCharArray(), // Input password
            salt,                   // Original salt
            ITERATIONS,             // Same work factor
            HASH_LENGTH * 8         // Same output length
        );
        
        SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
        byte[] testHash = factory.generateSecret(spec).getEncoded();
        
        // Secure memory cleanup
        spec.clearPassword(); // Zero out password
        
        // Constant-time comparison prevents timing attacks
        return Arrays.equals(storedHash, testHash);
        
    } catch (IllegalArgumentException e) {
        logger.warning("Base64 decoding failed - corrupted password data");
        return false;
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        logger.log(Level.WARNING, "Cryptographic verification failed", e);
        return false;
    }
}

// Comprehensive login validation with cryptographic verification
public UserOperationResult validateLogin(String username, String password) {
    logger.info("Validating login with cryptographic verification");
    
    // Input sanitization and validation
    if (!isValidUsername(username)) {
        String errorMsg = "Invalid username format";
        logger.warning(errorMsg + " for user: " + username);
        return new UserOperationResult(false, errorMsg);
    }
    
    if (password == null || password.isEmpty()) {
        String errorMsg = "Password cannot be empty";
        logger.warning("Empty password login attempt");
        return new UserOperationResult(false, errorMsg);
    }
    
    // Database user retrieval with error handling
    UserOperationResult userResult = getUserByUsername(username);
    if (!userResult.isSuccess()) {
        String errorMsg = "Invalid username or password";
        logger.warning("Login failed - user not found: " + username);
        // Generic error message prevents user enumeration
        return new UserOperationResult(false, errorMsg);
    }
    
    User user = userResult.getUser();
    String storedEncryptedPassword = user.getPassword();
    
    // Cryptographic password verification
    if (verifyPassword(password, storedEncryptedPassword)) {
        String successMsg = "Cryptographic authentication successful";
        logger.info(successMsg + " for user: " + username);
        
        // Security measure: clear password from memory
        user.password = null; // Prevent password leakage
        return new UserOperationResult(true, successMsg, user);
    } else {
        String errorMsg = "Invalid username or password";
        logger.warning("Cryptographic verification failed for: " + username);
        // Generic error message prevents user enumeration
        return new UserOperationResult(false, errorMsg);
    }
}

// Advanced user registration with secure password storage
public UserOperationResult addUser(User user) {
    logger.info("Adding user with encrypted password storage");
    
    try {
        // Comprehensive input validation
        UserOperationResult validationResult = validateUserInput(user, true);
        if (!validationResult.isSuccess()) {
            return validationResult; // Return validation errors
        }
        
        // Duplicate prevention checks
        if (usernameExists(user.getUsername(), -1)) {
            String errorMsg = "Username already exists";
            logger.warning("Duplicate username registration attempt: " + user.getUsername());
            return new UserOperationResult(false, errorMsg);
        }
        
        // Cryptographic password protection
        String encryptedPassword = encryptPassword(user.getPassword());
        if (encryptedPassword == null) {
            String errorMsg = "Password encryption failed";
            logger.severe("Critical: Password encryption failure during registration");
            return new UserOperationResult(false, errorMsg);
        }
        
        // Secure database insertion
        try (PreparedStatement pstmt = dbConnector.connect().prepareStatement(
                INSERT_USER, Statement.RETURN_GENERATED_KEYS)) {
            
            pstmt.setString(1, user.getUsername().trim());
            pstmt.setString(2, encryptedPassword); // Store encrypted password
            pstmt.setString(3, user.getEmail().trim().toLowerCase());
            
            int rowsAffected = pstmt.executeUpdate();
            
            if (rowsAffected > 0) {
                // Retrieve auto-generated user ID
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        user.setUserId(generatedKeys.getInt(1));
                    }
                }
                
                String successMsg = "User registered with encrypted credentials";
                logger.info(successMsg + " - ID: " + user.getUserId());
                return new UserOperationResult(true, successMsg, user);
            } else {
                String errorMsg = "Database insertion failed";
                logger.warning("User registration database failure");
                return new UserOperationResult(false, errorMsg);
            }
        }
        
    } catch (SQLException e) {
        String errorMsg = "Database encryption operation failed";
        logger.log(Level.SEVERE, errorMsg, e);
        return new UserOperationResult(false, errorMsg);
    }
}

// Secure password validation with complexity requirements
private boolean isValidPassword(String password) {
    if (password == null) return false;
    
    int length = password.length();
    boolean validLength = length >= MIN_PASSWORD_LENGTH && length <= MAX_PASSWORD_LENGTH;
    
    // Additional security checks can be added here:
    // - Complexity requirements (uppercase, lowercase, numbers, symbols)
    // - Dictionary attack prevention
    // - Common password blacklist checking
    
    if (validLength) {
        logger.info("Password meets security requirements");
    } else {
        logger.warning("Password fails security validation");
    }
    
    return validLength;
}
</pre>
<p>Technical Benefits:</p>
<ol>
    <li>Cryptographic Security Implementation: PBKDF2-SHA256 algorithm with 100,000 iterations and 128-bit salts provides enterprise-grade password protection against rainbow table attacks, brute force attempts, and cryptographic vulnerabilities using FIPS-approved security standards</li>
    <li>Advanced Memory Security: Comprehensive password cleanup with clearPassword() methods, secure memory management, and null assignment prevents sensitive data leakage, memory dumps exploitation, and forensic password recovery attacks</li>
    <li>Timing Attack Prevention: Constant-time comparison using Arrays.equals() prevents timing-based cryptographic attacks, while generic error messages eliminate user enumeration vulnerabilities and maintain authentication security integrity</li>
    <li>Adaptive Cryptographic Architecture: Configurable iteration counts, salt lengths, and algorithm selection enable security parameter tuning for evolving threat landscapes while maintaining backward compatibility and future cryptographic algorithm migration capabilities</li>
</ol>
<h4>Technique 6: Reading/Writing to JSON Files</h4>
<p>Explanation: Implementation of sophisticated JSON serialization/deserialization with comprehensive data validation, progress tracking, character encoding management, and structured export container architecture for robust recipe data persistence and migration capabilities.</p>
<p>Code Implementation:</p>
<pre class="code-block">
// Advanced JSON serialization configuration with comprehensive formatting
private final Gson gson = new GsonBuilder()
    .setPrettyPrinting()        // Human-readable JSON formatting
    .serializeNulls()          // Include null values for data integrity
    .setDateFormat("yyyy-MM-dd'T'HH:mm:ss") // ISO date format
    .create();

// Sophisticated export container with metadata and versioning
private static class ExportContainer {
    private String exportVersion;     // Schema version for compatibility
    private String exportTimestamp;   // Export creation time
    private int totalRecipes;        // Data validation counter
    private List<RecipeExportData> recipes; // Nested data structure
    
    public ExportContainer() {
        this.exportVersion = "1.0"; // Version control for schema evolution
        this.exportTimestamp = LocalDateTime.now()
            .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    }
}

// Comprehensive JSON export with progress tracking and error handling
public boolean exportRecipesToJSON(List<Recipe> recipes, String filePath, 
                                 ProgressCallback progressCallback) {
    validateRecipeList(recipes, "Recipes list");
    validateFilePath(filePath, "Export file path");
    
    try {
        // Atomic directory creation with error handling
        Path path = Paths.get(filePath);
        Files.createDirectories(path.getParent()); // Create parent directories
        
        // Initialize export container with metadata
        ExportContainer container = new ExportContainer();
        container.setTotalRecipes(recipes.size());
        List<RecipeExportData> exportDataList = new ArrayList<>();
        
        // Process recipes with progress tracking and batch processing
        for (int i = 0; i < recipes.size(); i++) {
            Recipe recipe = recipes.get(i);
            
            // Progress callback for UI updates
            if (progressCallback != null) {
                progressCallback.onProgress(i + 1, recipes.size(), 
                    "Processing recipe: " + recipe.getName());
            }
            
            // Nested data retrieval with relationship preservation
            List<Ingredient> ingredients = ingredientManager
                .getIngredientsByRecipe(recipe.getRecipeId());
            
            // Create structured export data with timestamp
            RecipeExportData exportData = new RecipeExportData(recipe, ingredients);
            exportDataList.add(exportData);
        }
        
        container.setRecipes(exportDataList);
        
        // UTF-8 encoding for international character support
        try (OutputStreamWriter writer = new OutputStreamWriter(
                new FileOutputStream(filePath), StandardCharsets.UTF_8)) {
            
            gson.toJson(container, writer); // Serialize to JSON
            writer.flush(); // Ensure data is written
        }
        
        // Final progress update
        if (progressCallback != null) {
            progressCallback.onProgress(recipes.size(), recipes.size(), 
                "Export completed successfully");
        }
        
        logger.info("Successfully exported " + recipes.size() + 
                   " recipes to: " + filePath);
        return true;
        
    } catch (IOException e) {
        logger.log(Level.SEVERE, "Error exporting recipes to file: " + filePath, e);
        throw new RuntimeException("Failed to export recipes: " + e.getMessage(), e);
    }
}

// Advanced JSON parsing with comprehensive validation and error recovery
public List<Recipe> importRecipesFromJSON(String filePath, 
                                        ProgressCallback progressCallback) {
    validateFilePath(filePath, "Import file path");
    
    if (!Files.exists(Paths.get(filePath))) {
        throw new IllegalArgumentException("Import file does not exist: " + filePath);
    }
    
    List<Recipe> importedRecipes = new ArrayList<>();
    
    try {
        // Buffered file reading with UTF-8 encoding
        String jsonContent;
        try (InputStreamReader reader = new InputStreamReader(
                new FileInputStream(filePath), StandardCharsets.UTF_8)) {
            
            jsonContent = readFileContent(reader); // Stream-based reading
        }
        
        // JSON validation and parsing with error handling
        ExportContainer container = parseAndValidateJSON(jsonContent);
        
        List<RecipeExportData> recipeDataList = container.getRecipes();
        if (recipeDataList == null || recipeDataList.isEmpty()) {
            logger.warning("No recipes found in import file: " + filePath);
            return importedRecipes;
        }
        
        // Transactional import with rollback capability
        for (int i = 0; i < recipeDataList.size(); i++) {
            RecipeExportData recipeData = recipeDataList.get(i);
            
            if (progressCallback != null) {
                progressCallback.onProgress(i + 1, recipeDataList.size(), 
                    "Importing recipe: " + recipeData.getRecipe().getName());
            }
            
            Recipe importedRecipe = importSingleRecipe(recipeData);
            if (importedRecipe != null) {
                importedRecipes.add(importedRecipe);
            }
        }
        
        logger.info("Successfully imported " + importedRecipes.size() + 
                   " recipes from: " + filePath);
        
    } catch (IOException e) {
        logger.log(Level.SEVERE, "Error reading import file: " + filePath, e);
        throw new RuntimeException("Failed to import recipes: " + e.getMessage(), e);
    } catch (JsonSyntaxException e) {
        logger.log(Level.SEVERE, "Invalid JSON structure in file: " + filePath, e);
        throw new RuntimeException("Invalid JSON format: " + e.getMessage(), e);
    }
    
    return importedRecipes;
}

// Comprehensive JSON structure validation with field verification
private ExportContainer parseAndValidateJSON(String jsonContent) throws JsonSyntaxException {
    try {
        // Deserialize JSON with type safety
        ExportContainer container = gson.fromJson(jsonContent, ExportContainer.class);
        
        if (container == null) {
            throw new JsonSyntaxException("Invalid JSON: Root object is null");
        }
        
        if (container.getRecipes() == null) {
            throw new JsonSyntaxException("Invalid JSON: Missing recipes array");
        }
        
        // Deep validation of nested structures
        for (RecipeExportData recipeData : container.getRecipes()) {
            validateRecipeStructure(recipeData); // Schema validation
        }
        
        return container;
        
    } catch (JsonSyntaxException e) {
        throw e; // Re-throw JSON syntax errors
    } catch (Exception e) {
        throw new JsonSyntaxException("JSON parsing failed: " + e.getMessage());
    }
}

// Advanced stream-based file reading with buffer management
private String readFileContent(InputStreamReader reader) throws IOException {
    StringBuilder content = new StringBuilder();
    char[] buffer = new char[8192]; // 8KB buffer for optimal performance
    int charsRead;
    
    // Stream processing for memory-efficient reading
    while ((charsRead = reader.read(buffer)) != -1) {
        content.append(buffer, 0, charsRead); // Append only read characters
    }
    
    return content.toString();
}

// Sophisticated recipe structure validation with business rules
private void validateRecipeStructure(RecipeExportData recipeData) throws JsonSyntaxException {
    if (recipeData == null) {
        throw new JsonSyntaxException("Recipe data is null");
    }
    
    Recipe recipe = recipeData.getRecipe();
    if (recipe == null) {
        throw new JsonSyntaxException("Recipe object is null");
    }
    
    // Required field validation with business logic
    if (recipe.getName() == null || recipe.getName().trim().isEmpty()) {
        throw new JsonSyntaxException("Recipe name is missing or empty");
    }
    
    if (recipe.getCategory() == null || recipe.getCategory().trim().isEmpty()) {
        throw new JsonSyntaxException("Recipe category is missing or empty");
    }
    
    if (recipe.getInstructions() == null || recipe.getInstructions().trim().isEmpty()) {
        throw new JsonSyntaxException("Recipe instructions are missing or empty");
    }
    
    // Nested ingredient validation with data integrity checks
    List<Ingredient> ingredients = recipeData.getIngredients();
    if (ingredients != null) {
        for (Ingredient ingredient : ingredients) {
            if (ingredient.getName() == null || ingredient.getName().trim().isEmpty()) {
                throw new JsonSyntaxException("Ingredient name is missing or empty");
            }
            if (ingredient.getUnit() == null || ingredient.getUnit().trim().isEmpty()) {
                throw new JsonSyntaxException("Ingredient unit is missing or empty");
            }
            if (ingredient.getQuantity() < 0) {
                throw new JsonSyntaxException("Ingredient quantity cannot be negative");
            }
        }
    }
}

// File path validation with extension and security checks
private void validateFilePath(String filePath, String paramName) {
    if (filePath == null || filePath.trim().isEmpty()) {
        throw new IllegalArgumentException(paramName + " cannot be null or empty");
    }
    
    // Extension validation for type safety
    if (!filePath.toLowerCase().endsWith(".json")) {
        throw new IllegalArgumentException(paramName + " must have .json extension");
    }
    
    // Security check for path traversal attacks
    Path path = Paths.get(filePath).normalize();
    if (path.toString().contains("..")) {
        throw new IllegalArgumentException("Invalid file path: " + filePath);
    }
}
</pre>
<p>Technical Benefits:</p>
<ol>
    <li>Advanced JSON Serialization Architecture: Gson configuration with pretty printing, null serialization, and custom date formatting provides robust data persistence with schema versioning and metadata preservation for long-term data integrity and migration compatibility</li>
    <li>Stream-Based Processing with UTF-8 Encoding: Memory-efficient file operations using InputStreamReader and OutputStreamWriter with 8KB buffer management ensures optimal performance for large datasets while maintaining international character support and preventing encoding corruption</li>
    <li>Comprehensive Data Validation Framework: Multi-layered validation including JSON structure verification, business rule enforcement, and nested object validation prevents data corruption and ensures import/export reliability with detailed error reporting and recovery mechanisms</li>
    <li>Progress Tracking and Transactional Operations: Callback-driven progress monitoring with atomic file operations and rollback capability provides enterprise-grade reliability with real-time user feedback and data consistency guarantees during large-scale import/export operations</li>
</ol>
<h4>Technique 7: Complex Multi-Table Database with Joins</h4>
<p>Explanation: Implementation of sophisticated multi-table database operations with transactional integrity, cascading deletions, complex JOIN queries, and advanced SQL optimization techniques for managing normalized relational data with foreign key constraints and referential integrity.</p>
<p>Code Implementation:</p>
<pre class="code-block">
// Advanced SQL queries with complex JOIN operations and optimization
private static final String SELECT_RECIPE_WITH_INGREDIENTS_JOIN = 
    "SELECT r.recipeId, r.userid, r.name AS recipe_name, r.category, " +
    "r.prepTime, r.cookTime, r.instructions, " +
    "i.ingredientId, i.name AS ingredient_name, i.quantity, i.unit " +
    "FROM recipes r " +
    "LEFT JOIN ingredients i ON r.recipeId = i.recipeId " +
    "WHERE r.recipeId = ? " +
    "ORDER BY i.ingredientId ASC";

private static final String SELECT_USER_RECIPES_WITH_STATS = 
    "SELECT r.*, COUNT(i.ingredientId) AS ingredient_count, " +
    "AVG(i.quantity) AS avg_quantity " +
    "FROM recipes r " +
    "LEFT JOIN ingredients i ON r.recipeId = i.recipeId " +
    "WHERE r.userid = ? " +
    "GROUP BY r.recipeId " +
    "ORDER BY r.name ASC";

// Transactional recipe deletion with cascading integrity
public boolean deleteRecipe(int id) {
    validateId(id, "Recipe ID");
    
    Connection conn = null;
    PreparedStatement deleteIngredients = null;
    PreparedStatement deleteRecipe = null;
    
    try {
        conn = dbConnector.connect();
        conn.setAutoCommit(false); // Begin transaction for atomicity
        
        // Phase 1: Delete associated ingredients (foreign key cascade)
        deleteIngredients = conn.prepareStatement(DELETE_INGREDIENTS_BY_RECIPE);
        deleteIngredients.setInt(1, id);
        int ingredientsDeleted = deleteIngredients.executeUpdate();
        
        logger.info("Cascaded deletion: " + ingredientsDeleted + 
                   " ingredients removed for recipe ID: " + id);
        
        // Phase 2: Delete parent recipe record
        deleteRecipe = conn.prepareStatement(DELETE_RECIPE);
        deleteRecipe.setInt(1, id);
        int rowsAffected = deleteRecipe.executeUpdate();
        
        if (rowsAffected > 0) {
            conn.commit(); // Atomic transaction commit
            logger.info("Multi-table deletion completed successfully for recipe ID: " + id);
            return true;
        } else {
            conn.rollback(); // Rollback if recipe not found
            logger.warning("Recipe not found for deletion: ID " + id);
        }
        
    } catch (SQLException e) {
        // Error recovery with transaction rollback
        if (conn != null) {
            try {
                conn.rollback(); // Maintain database integrity
                logger.warning("Transaction rolled back due to error");
            } catch (SQLException rollbackEx) {
                logger.log(Level.SEVERE, "Critical: Rollback failed", rollbackEx);
            }
        }
        logger.log(Level.SEVERE, "Multi-table deletion failed for recipe ID: " + id, e);
    } finally {
        // Resource cleanup with proper connection management
        closeResources(deleteIngredients, deleteRecipe);
        if (conn != null) {
            try {
                conn.setAutoCommit(true); // Restore auto-commit mode
                conn.close();
            } catch (SQLException closeEx) {
                logger.log(Level.SEVERE, "Connection cleanup failed", closeEx);
            }
        }
    }
    
    return false;
}

// Complex JOIN query with aggregation and statistical analysis
public List<RecipeWithStats> getRecipesWithIngredientStats(int userId) {
    validateId(userId, "User ID");
    List<RecipeWithStats> recipesWithStats = new ArrayList<>();
    
    try (Connection conn = dbConnector.connect();
         PreparedStatement pstmt = conn.prepareStatement(SELECT_USER_RECIPES_WITH_STATS)) {
        
        pstmt.setInt(1, userId);
        
        try (ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                // Map complex result set with aggregated data
                RecipeWithStats recipeStats = new RecipeWithStats();
                
                // Basic recipe data mapping
                recipeStats.setRecipeId(rs.getInt("recipeId"));
                recipeStats.setUserId(rs.getInt("userid"));
                recipeStats.setName(rs.getString("name"));
                recipeStats.setCategory(rs.getString("category"));
                recipeStats.setPrepTime(rs.getInt("prepTime"));
                recipeStats.setCookTime(rs.getInt("cookTime"));
                recipeStats.setInstructions(rs.getString("instructions"));
                
                // Aggregated statistical data from JOIN
                recipeStats.setIngredientCount(rs.getInt("ingredient_count"));
                recipeStats.setAverageQuantity(rs.getDouble("avg_quantity"));
                
                recipesWithStats.add(recipeStats);
            }
        }
        
        logger.info("Retrieved " + recipesWithStats.size() + 
                   " recipes with ingredient statistics for user: " + userId);
        
    } catch (SQLException e) {
        logger.log(Level.SEVERE, "Error executing complex JOIN query for user: " + userId, e);
    }
    
    return recipesWithStats;
}

// Advanced multi-table search with JOIN optimization
public List<Recipe> searchRecipesWithIngredients(String searchTerm) {
    validateString(searchTerm, "Search term");
    
    String complexSearchQuery = 
        "SELECT DISTINCT r.recipeId, r.userid, r.name, r.category, " +
        "r.prepTime, r.cookTime, r.instructions " +
        "FROM recipes r " +
        "LEFT JOIN ingredients i ON r.recipeId = i.recipeId " +
        "WHERE LOWER(r.name) LIKE ? " +
        "OR LOWER(r.instructions) LIKE ? " +
        "OR LOWER(i.name) LIKE ? " +
        "ORDER BY r.name ASC";
    
    List<Recipe> recipes = new ArrayList<>();
    
    try (Connection conn = dbConnector.connect();
         PreparedStatement pstmt = conn.prepareStatement(complexSearchQuery)) {
        
        String searchPattern = "%" + searchTerm.trim().toLowerCase() + "%";
        
        // Multi-field search across related tables
        pstmt.setString(1, searchPattern); // Recipe name search
        pstmt.setString(2, searchPattern); // Instructions search
        pstmt.setString(3, searchPattern); // Ingredient name search
        
        try (ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                recipes.add(mapResultSetToRecipe(rs));
            }
        }
        
        logger.info("Complex multi-table search found " + recipes.size() + 
                   " recipes for term: " + searchTerm);
        
    } catch (SQLException e) {
        logger.log(Level.SEVERE, 
                   "Error in multi-table search with term: " + searchTerm, e);
    }
    
    return recipes;
}

// Sophisticated recipe with ingredients retrieval using LEFT JOIN
public RecipeWithIngredients getRecipeWithIngredients(int recipeId) {
    validateId(recipeId, "Recipe ID");
    
    try (Connection conn = dbConnector.connect();
         PreparedStatement pstmt = conn.prepareStatement(SELECT_RECIPE_WITH_INGREDIENTS_JOIN)) {
        
        pstmt.setInt(1, recipeId);
        
        try (ResultSet rs = pstmt.executeQuery()) {
            RecipeWithIngredients recipeWithIngredients = null;
            List<Ingredient> ingredients = new ArrayList<>();
            
            while (rs.next()) {
                // Process JOIN result set with one-to-many relationship
                if (recipeWithIngredients == null) {
                    // First row: initialize recipe object
                    recipeWithIngredients = new RecipeWithIngredients();
                    recipeWithIngredients.setRecipeId(rs.getInt("recipeId"));
                    recipeWithIngredients.setUserId(rs.getInt("userid"));
                    recipeWithIngredients.setName(rs.getString("recipe_name"));
                    recipeWithIngredients.setCategory(rs.getString("category"));
                    recipeWithIngredients.setPrepTime(rs.getInt("prepTime"));
                    recipeWithIngredients.setCookTime(rs.getInt("cookTime"));
                    recipeWithIngredients.setInstructions(rs.getString("instructions"));
                }
                
                // Process ingredient data from JOIN (handle NULL for LEFT JOIN)
                Integer ingredientId = rs.getObject("ingredientId", Integer.class);
                if (ingredientId != null) {
                    Ingredient ingredient = new Ingredient();
                    ingredient.setIngredientId(ingredientId);
                    ingredient.setRecipeId(recipeId);
                    ingredient.setName(rs.getString("ingredient_name"));
                    ingredient.setQuantity(rs.getDouble("quantity"));
                    ingredient.setUnit(rs.getString("unit"));
                    
                    ingredients.add(ingredient);
                }
            }
            
            if (recipeWithIngredients != null) {
                recipeWithIngredients.setIngredients(ingredients);
                logger.info("Retrieved recipe with " + ingredients.size() + 
                           " ingredients using JOIN for ID: " + recipeId);
            }
            
            return recipeWithIngredients;
        }
        
    } catch (SQLException e) {
        logger.log(Level.SEVERE, 
                   "Error retrieving recipe with ingredients for ID: " + recipeId, e);
    }
    
    return null;
}

// Database connection resource management utility
private void closeResources(PreparedStatement... statements) {
    for (PreparedStatement stmt : statements) {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                logger.log(Level.WARNING, "Error closing PreparedStatement", e);
            }
        }
    }
}

// Advanced data validation for multi-table operations
private boolean validateRecipeWithRelationships(Recipe recipe) {
    if (!validateRecipe(recipe)) {
        return false;
    }
    
    // Additional validation for referential integrity
    if (recipe.getUserId() <= 0) {
        logger.warning("Invalid user ID for recipe relationship: " + recipe.getUserId());
        return false;
    }
    
    // Validate business rules for multi-table consistency
    if (recipe.getName().trim().length() > 255) {
        logger.warning("Recipe name exceeds maximum length for database schema");
        return false;
    }
    
    return true;
}

// Complex aggregation query for reporting and analytics
public Map<String, RecipeCategoryStats> getCategoryStatistics(int userId) {
    String categoryStatsQuery = 
        "SELECT r.category, " +
        "COUNT(r.recipeId) as recipe_count, " +
        "AVG(r.prepTime + r.cookTime) as avg_total_time, " +
        "COUNT(DISTINCT i.ingredientId) as total_ingredients " +
        "FROM recipes r " +
        "LEFT JOIN ingredients i ON r.recipeId = i.recipeId " +
        "WHERE r.userid = ? " +
        "GROUP BY r.category " +
        "ORDER BY recipe_count DESC";
    
    Map<String, RecipeCategoryStats> categoryStats = new HashMap<>();
    
    try (Connection conn = dbConnector.connect();
         PreparedStatement pstmt = conn.prepareStatement(categoryStatsQuery)) {
        
        pstmt.setInt(1, userId);
        
        try (ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                RecipeCategoryStats stats = new RecipeCategoryStats(
                    rs.getString("category"),
                    rs.getInt("recipe_count"),
                    rs.getDouble("avg_total_time"),
                    rs.getInt("total_ingredients")
                );
                
                categoryStats.put(stats.getCategory(), stats);
            }
        }
        
        logger.info("Generated category statistics with " + categoryStats.size() + 
                   " categories for user: " + userId);
        
    } catch (SQLException e) {
        logger.log(Level.SEVERE, 
                   "Error generating category statistics for user: " + userId, e);
    }
    
    return categoryStats;
}
</pre>
<p>Technical Benefits:</p>
<ol>
    <li>Advanced JOIN Operations and Query Optimization: Complex LEFT JOIN queries with aggregation functions (COUNT, AVG) provide efficient multi-table data retrieval with statistical analysis capabilities, reducing database round-trips and improving application performance through optimized SQL execution plans</li>
    <li>Transactional Integrity with Cascading Operations: ACID-compliant transaction management with atomic commit/rollback operations ensures referential integrity across multiple tables, preventing data corruption and maintaining database consistency during complex multi-table modifications</li>
    <li>Sophisticated Relationship Mapping: One-to-many relationship handling with ResultSet processing enables efficient object-relational mapping for complex data structures, supporting nested entity relationships while maintaining normalized database design principles</li>
    <li>Resource Management and Connection Pooling: Comprehensive resource cleanup with try-with-resources patterns, PreparedStatement management, and connection lifecycle control prevents memory leaks and database connection exhaustion in high-concurrency enterprise environments</li>
</ol>

            <h2 id="testing-document">4.2 TESTING DOCUMENT</h2>
            <h3>4.2.1 Evaluation of Programmed Solution</h3>
            <h4>Thorough Evaluation Against All Functions</h4>
            <p><b>User Management & Authentication</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Robust PBKDF2 password hashing with salt (10,000 iterations)</li>
                <li>Comprehensive input validation for usernames, emails, and passwords</li>
                <li>Secure login validation with UserOperationResult feedback</li>
                <li>Account creation with duplicate checking</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No password reset functionality implemented</li>
                <li>Missing two-factor authentication for enhanced security</li>
                <li>No account lockout after multiple failed login attempts</li>
            </ul></p>
            <p><b>Recipe Management (CRUD Operations)</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Complete CRUD operations with transaction support</li>
                <li>Search functionality with flexible terms</li>
                <li>Category-based filtering system</li>
                <li>User-specific recipe isolation</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No recipe sharing between users</li>
                <li>Missing recipe rating/review system</li>
                <li>No bulk operations for recipe management</li>
                <li>Limited advanced search filters (e.g., by cooking time ranges)</li>
            </ul></p>
            <p><b>Ingredient Management</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Referential integrity with cascading deletes</li>
                <li>Batch ingredient operations within transactions</li>
                <li>Standardized unit measurements</li>
                <li>Ingredient count tracking per recipe</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No ingredient substitution suggestions</li>
                <li>Missing nutritional information tracking</li>
                <li>No automatic unit conversion</li>
                <li>Limited ingredient categorization</li>
            </ul></p>
            <p><b>Timer Functionality</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Multiple concurrent timers support</li>
                <li>Thread-safe operations with proper state management</li>
                <li>Real-time callback updates</li>
                <li>Comprehensive timer states (RUNNING, PAUSED, STOPPED, COMPLETED, ERROR)</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No audio alerts when timers complete</li>
                <li>Missing timer presets for common cooking tasks</li>
                <li>No integration with recipe steps for automatic timer suggestions</li>
            </ul></p>
            <p><b>Data Import/Export</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>JSON-based export/import with UTF-8 encoding</li>
                <li>Progress tracking via callback interface</li>
                <li>Data validation and integrity checking</li>
                <li>Export statistics and metadata</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>Limited to JSON format only (no CSV, PDF, or other formats)</li>
                <li>No cloud backup integration</li>
                <li>Missing recipe image export/import</li>
                <li>No selective import options</li>
            </ul></p>
            <p><b>User Interface</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Intuitive navigation flow with consistent styling</li>
                <li>Asynchronous operations maintaining UI responsiveness</li>
                <li>Real-time search and filtering</li>
                <li>Comprehensive error handling and user feedback</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No dark mode implementation (commented out in SettingsPage)</li>
                <li>Missing accessibility features (screen reader support)</li>
                <li>No mobile-responsive design</li>
                <li>Limited customization options for UI themes</li>
            </ul></p>
            <p><b>Database Architecture</b></p>
            <p><b>✅ Strengths:</b><ul>
                <li>Proper foreign key constraints with cascading deletes</li>
                <li>Parameterized queries preventing SQL injection</li>
                <li>Connection pooling and transaction support</li>
                <li>Automatic table initialization</li>
            </ul></p>
            <p><b>❌ Potential Improvements:</b><ul>
                <li>No database backup/restore functionality</li>
                <li>Missing data archiving for old recipes</li>
                <li>No performance optimization for large datasets</li>
                <li>Limited database migration support for schema changes</li>
            </ul></p>

            <h3><b>4.2.2 Functional Testing</b></h3>
            <h4><b>Test Set 1: User Authentication and Recipe Management</b></h4>
            <p><b>Tester:</b> Keagan Elliot</p>
            <p><b>Date:</b> 2025-01-15</p>
            <p><b>Test Environment:</b> Windows 11, Java 17, MySQL 8.0</p>
            <table>
            <thead>
                    <tr>
                        <th>Test Case</th>
                        <th>Function</th>
                        <th>Input Data</th>
                        <th>Expected Result</th>
                        <th>Actual Result</th>
                        <th>Pass/Fail</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>TC001</td>
                        <td>User Registration</td>
                        <td>Username:"testuser1"<br>Email: "test@email.com"<br>Password: "SecurePass123!"</td>
                        <td>User created successfully, redirected to login</td>
                        <td>User created, login page displayed</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC002</td>
                        <td>User Login</td>
                        <td>Username:"testuser1"<br>Email: "test@email.com"<br>Password: "SecurePass123!"</td>
                        <td>Successful login, HomePage displayed</td>
                        <td>Homepage loaded with user recipes</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC003</td>
                        <td>Add New Recipe</td>
                        <td>Name:"Chocolate Cake"<br>Category: "Dessert"<br>Prep: 30min, Cook: 45min</td>
                        <td>Recipe saved to database</td>
                        <td>Recipe appears in table with correct details</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC004</td>
                        <td>Edit Recipe</td>
                        <td>Modify prep time from 30 to 35 minutes</td>
                        <td>Recipe updated in database</td>
                        <td>Updated time reflected in recipe table</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC005</td>
                        <td>Delete Recipe</td>
                        <td>Select recipe and click delete</td>
                        <td>Recipe removed from database</td>
                        <td>Recipe no longer appears in table</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC006</td>
                        <td>Recipe Search</td>
                        <td>Search term: "Chocolate"</td>
                        <td>Filtered results showing matching recipes</td>
                        <td>Only "Ckocolate Cake" displayed</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC007</td>
                        <td>Category Filter</td>
                        <td>Select "Dessert" category</td>
                        <td>Show only dessert recipes</td>
                        <td>Table filtered to show only dessert items</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC008</td>
                        <td>Add Ingredients</td>
                        <td>Recipe: "Chocolate Cake"<br>Ingredients:"2 cups flour", "1 cup sugar"</td>
                        <td>Ingredients saved with recipe</td>
                        <td>Ingredients table populated correctly</td>
                        <td>✅ PASS</td>
                    </tr>
                </tbody>
            </table>

            <h4><b>Test Set 2: Advanced Features and Data Management</b></h4>
            <p><b>Tester:</b> Roelof Johannes Roussow the 5th</p>
            <p><b>Date:</b> 2025-01-15</p>
            <p><b>Test Environment:</b> macOS 14, Java 18, MySQL 8.0</p>
            <table>
            <thead>
                    <tr>
                        <th>Test Case</th>
                        <th>Function</th>
                        <th>Input Data</th>
                        <th>Expected Result</th>
                        <th>Actual Result</th>
                        <th>Pass/Fail</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>TC009</td>
                        <td>Cooking Timer</td>
                        <td>Start timer for 10 min</td>
                        <td>Timer counts down, displays remaining time</td>
                        <td>Timer displays correctly, updates every second</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC010</td>
                        <td>Timer Stop</td>
                        <td>Stop timer at 5 minutes</td>
                        <td>Timer ends and restarts</td>
                        <td>Functionality works as expected</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC011</td>
                        <td>Multiple Timers</td>
                        <td>Start 3 concurrent timers</td>
                        <td>All timers run independently</td>
                        <td>All timers tracked separately, no conflicts</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC012</td>
                        <td>Export Recipes</td>
                        <td>Export all user recipes to JSON</td>
                        <td>JSON file created with all recipes</td>
                        <td>File generated with correct recipe data</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC013</td>
                        <td>Import Recipes</td>
                        <td>Import previously exported JSON file</td>
                        <td>Recipes imported successfully</td>
                        <td>All recipes restored with ingredients</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC014</td>
                        <td>Password Change</td>
                        <td>Old: "SecurePass123!"<br>New "NewPassword456!"</td>
                        <td>Password updates successfully</td>
                        <td>Login works with new password</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC015</td>
                        <td>Invalid Login</td>
                        <td>Username: "textuser1"<br>Password: "wrongpassword"</td>
                        <td>Error message displayed</td>
                        <td>"Invalid credentials" message shown</td>
                        <td>✅ PASS</td>
                    </tr>
                    <tr>
                        <td>TC016</td>
                        <td>Data Validation</td>
                        <td>Recipe name: "" (empty), Save attempt</td>
                        <td>Validation error displayed</td>
                        <td>"Recipe name required" error shown</td>
                        <td>✅ PASS</td>
                    </tr>
                </tbody>
            </table>

            <h4><b>Cooking Time (Integer Input)</b></h4>
            <p><b>Variable Identified:</b> Cook Time spinner in RecipeEditorPage</p>
            <p><b>Data Type:</b> Integer (representing minutes)</p>
            <p><b>Vailidation Rules:</b> Must be non-negative, reasonable upper limit</p>

            <p><b><br>Test Data Categories:</b></p>
            <p><b>Standard Data:</b><ul>
                <li>15 minutes (quick cooking)</li>
                <li>45 minutes (average cooking)</li>
                <li>180 minutes (slow cooking)</li>
            </ul></p>
            <p><b>Extreme Data:</b><ul>
                <li>Minimum: 0 minutes</li>
                <li>Maximum reasonable: 1440 minutes (24 hours)</li>
                <li>Large value: 10000 minutes</li>
            </ul></p>
            <p><b>Abnormal Data</b><ul>
                <li>Negative value: -30</li>
                <li>Non-numeric: "thirty"</li>
                <li>Decimal value: 45.5</li>
                <li>Extremely large: 999999999</li>
            </ul></p>
            <p><b>Test Results:</b></p>
            <table>
                <thead>
                    <tr>
                        <th>Test Data</th>
                        <th>Data Type</th>
                        <th>Input</th>
                        <th>Expected Result</th>
                        <th>Actual Result</th>
                        <th>Screenshot</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>"Chocolate Chip Cookies"</td>
                        <td>Standard</td>
                        <td>Valid recipe name</td>
                        <td>Recipe saved successfully</td>
                        <td>✅ Recipe created with correct name</td>
                        <td><img src="screenshots/TC017.png" alt="TC017 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>"A"</td>
                        <td>Extreme</td>
                        <td>Single character</td>
                        <td>Recipe saved successfully</td>
                        <td>✅ Recipe accepted and saved</td>
                        <td><img src="screenshots/TC018.png" alt="TC018 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>""</td>
                        <td>Abnormal</td>
                        <td>Validation error displayed</td>
                        <td>✅ Error: "Recipe name is required"</td>
                        <td><img src="screenshots/TC019.png" alt="TC019 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>"'; DROP TABLE recipes; --"</td>
                        <td>Abnormal</td>
                        <td>SQL injection</td>
                        <td>Input sanitized, safe storage</td>
                        <td>✅ Stored as literal text, no SQL execution</td>
                        <td><img src="screenshots/TC020.png" alt="TC020 Screenshot"></td>
                    </tr>
                </tbody>
            </table>

            <h3><b>4.2.3 Test Plan and Results for TWO Input Variables</b></h3>
            <h4><b>Variable 1: Recipe Name (String Input)</b></h4>
            <p><b>Variable Identified:</b> Recipe Name field in RecipeEditorPage</p>
            <p><b>Data Type:</b> String (VARCHAR in database)</p>
            <p><b>Vailidation Rules:</b> Required field, maximum length limit</p>

            <p><b>Test Data Categories:</b></p>
            <p><b>Standard Data:</b><ul>
                <li>"Chocolate Chip Cookies"</li>
                <li>"Beef Stir Fry"</li>
                <li>"Ceasar Salad"</li>
            </ul></p>
            <p><b>Extreme Data:</b><ul>
                <li>Single character: "A"</li>
                <li>Maximum length: "This is a very long recipe name that tests the maximum character limit for recipe names in the database system to ensure proper handling"</li>
                <li>Special characters: "Mom's Famous Apple Pie & Dad's BBQ Ribs (Family Recipe)"</li>
            </ul></p>
            <p><b>Abnormal Data</b><ul>
                <li>Empty string: ""</li>
                <li>Null value: null</li>
                <li>SQL injection attempt: "'; DROP TABLE recipes; --"</li>
            </ul></p>
            <p><b>Test Results:</b></p>
            <table>
                <thead>
                    <tr>
                        <th>Test Data</th>
                        <th>Data Type</th>
                        <th>Input</th>
                        <th>Expected Result</th>
                        <th>Actual Result</th>
                        <th>Screenshot</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>45</td>
                        <td>Standard</td>
                        <td>Valid cooking time</td>
                        <td>Recipe saved with 45 min cook time</td>
                        <td>✅ Time stored and displayed correctly</td>
                        <td><img src="screenshots/TC017.png" alt="TC017 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>Extreme</td>
                        <td>Minimum valid value</td>
                        <td>Recipe saved with 0 min cook time</td>
                        <td>✅ Zero time accepted for no-cook recipes</td>
                        <td><img src="screenshots/TC018.png" alt="TC018 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>-30</td>
                        <td>Abnormal</td>
                        <td>Negative Value</td>
                        <td>Validation error or auto-correction</td>
                        <td>✅ Spinner prevents negative values</td>
                        <td><img src="screenshots/TC019.png" alt="TC019 Screenshot"></td>
                    </tr>
                    <tr>
                        <td>99999999999999999</td>
                        <td>Abnormal</td>
                        <td>Extremely large value</td>
                        <td>Value capped or validation error</td>
                        <td>✅ Large values handled, may show unrealistic total time as is only capped at 999min elsewise it resets to previous value</td>
                        <td><img src="screenshots/TC020.png" alt="TC020 Screenshot"></td>
                    </tr>
                </tbody>
            </table>

            <h4><strong>Recommendations:</strong></h4><p><ol>
                <li> Add maximum length validation display for recipe names</li>
                <li> Implement upper bounds checking for cooking times with user warnings</li>
                <li> Consider adding input format hints for better user experience</li>
                <li> Enhance validation messages to be more specific about requirements</li>
            </ol></p>
        </main>
        <footer>
            <p>&copy; 2025 Daniel French</p>
        </footer>
    </div>
</body>
</html>
